To avoid downtime, read exploit code carefully, modify it as needed and test against sandboxed target whenever possible

# Fixing Memory Corruption Exploits

## Buffer Overflow in a Nutshell
A lot of this has been fixed by ASLR and Executable Space Protection among other things.


Programmes (pre-)allocate memory for certain things. This allocated memory is called the buffer. The buffer may "overflow" if something is stored in it that is larger than the buffer's size (e.g. an 80 character password where memory was allocated for 64 characters). When this happens, the extra characters/bytes are written to the memory adjecent to the buffer. When a function ends, it executes the _ret_ instruction, which loads the return address inside EIP/RIP (pointer that keeps track of current code instructions). By writing into the adjacent memory, the attacker can therefore change the return address to take control of the programme and have it execute the attacker's code.

The general flow of a standard stack-based buffer overflow is fairly straightforward. The exploit will:

1. Create a large buffer to trigger the overflow.
2. Take control of EIP by overwriting a return address on the stack, padding the large buffer with an appropriate offset.
3. Include a chosen payload in the buffer prepended by an optional NOP sled.
4. Choose a correct return address instruction such as JMP ESP (or a different register) to redirect the execution flow to the payload.

Fixing these exploits may require changing several things:
- File paths
- IP addresses
- Ports
- URLs
- Return address (best practice: debug programme and find return address yourself)
- Payload
- More

